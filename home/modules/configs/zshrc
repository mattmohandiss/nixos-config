# Navigation / globbing quality of life
setopt AUTO_CD                       # 'foo' == 'cd foo' if it's a dir
setopt AUTO_PUSHD                    # cd pushes dir stack; use 'dirs' to see
setopt PUSHD_IGNORE_DUPS             # Don't duplicate entries in stack
setopt GLOB_DOTS                     # Include dotfiles in globs (e.g. * matches .env)
setopt NUMERIC_GLOB_SORT             # Sort files numerically (2<10)
setopt NO_BEEP                       # Disable terminal bell

# Smarter completion UI
zmodload zsh/complist
zstyle ':completion:*' menu select   # Arrow-key selection
zstyle ':completion:*' matcher-list 'm:{a-z}={A-Za-z}' # Case-insensitive
zstyle ':completion:*' list-colors '''' # Use LS_COLORS
zstyle ':completion:*' squeeze-slashes true

# Prefer modern replacements
alias ls='eza --group-directories-first --icons'  # Safer 'ls' upgrade
alias ll='ls -lh'                                 # Long, human sizes
alias la='ls -la'                                 # Show dotfiles
alias cat='bat'                                   # Pager with syntax highlight
alias grep='rg'                                   # Faster grep
alias find='fd'                                   # Friendly find
alias gs='git status -sb'                         # Concise git status

export EDITOR="nvim"                              # Default editor
export PAGER="less -R"                            # Preserve colors in pager

# fzf keybinds/completion (provided by programs.fzf.* below)
# zoxide (smart cd) hook
eval "$(zoxide init zsh)"

# Starship prompt (fast, pretty, git-aware)
eval "$(starship init zsh)"

# direnv hook (preserve existing functionality)
eval "$(direnv hook zsh)"

# Custom dev function
dev() {
    if [ -z "$1" ]; then
        echo "Usage: dev <directory_search_string>"
        return 1
    fi

    local target_dir
    target_dir=$(zoxide query "$1")

    if [ -z "$target_dir" ]; then
        echo "zoxide: no match found for '$1'"
        return 1
    fi

    cd "$target_dir"

    # 1. Get ID and resize current shell window to 33%
    local shell_win_id
    shell_win_id=$(niri msg --json focused-window | jq -r '.id')
    if [ -n "$shell_win_id" ]; then
        niri msg action set-column-width "33%" &> /dev/null
    fi

    # 2. Spawn nvim window and resize to 34%
    kitty --class "dev-nvim" nvim . &> /dev/null &
    local nvim_win_id
    for i in {1..10}; do
        nvim_win_id=$(niri msg --json windows | jq --arg app_id "dev-nvim" -r '.[] | select(.app_id == $app_id) | .id')
        if [ -n "$nvim_win_id" ]; then
            niri msg action focus-window -- "$nvim_win_id" &> /dev/null
            niri msg action set-column-width "67%" &> /dev/null
            break
        fi
        sleep 0.2
    done

    # 3. Spawn gemini window and resize to 33%
    kitty --class "dev-gemini" gemini &> /dev/null &
    local gemini_win_id
    for i in {1..10}; do
        gemini_win_id=$(niri msg --json windows | jq --arg app_id "dev-gemini" -r '.[] | select(.app_id == $app_id) | .id')
        if [ -n "$gemini_win_id" ]; then
            niri msg action focus-window -- "$gemini_win_id" &> /dev/null
            niri msg action set-column-width "33%" &> /dev/null
            break
        fi
        sleep 0.2
    done

    # 4. Re-focus the nvim window to start working
    if [ -n "$nvim_win_id" ]; then
        sleep 0.1 # Allow window events to settle before focusing
        niri msg action focus-window -- "$nvim_win_id" &> /dev/null
    fi
}
